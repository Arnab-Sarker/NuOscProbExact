# NuOscProbExact
Code to compute exact two- and three-neutrino oscillation probabilities using SU(2) and SU(3) expansions


## What is NuOscProbExact?

**NuOscProbExact** is a Python implementation of the method to compute exact two-flavor and three-flavor neutrino oscillation probabilities for arbitrary time-independent Hamiltonians presented in the paper [arXiv:1904.XXXXX](https://arxiv.org/abs/1904.XXXXX).  The method relies on expansions of the Hamiltonian and time-evolution operators in terms of SU(2) and SU(3) matrices in order to obtain concise, analytical, and exact expressions for the probabilities, that are also easy to implement and evaluate.  For details of the method, see the paper above.

**NuOscProbExact** was developed by Mauricio Bustamante, who also authored the paper [arXiv:1904.XXXXX](https://arxiv.org/abs/1904.XXXXX).  If you use it in your work, please follow the directions on [Citing](#citing).


## Requirements

**NuOscProbExact** is fully written in Python 3.  It uses standard modules that are available, sometimes by default, as part of most Python installations, either stand-alone or via Anaconda:

* The two core modules (`oscprob2nu.py` and `oscprob3nu.py`) require only `numpy` and `cmath`.  These are the bare minimum requirements.

* The modules containing example Hamiltonians (`hamiltonians2nu.py` and `hamiltonians3nu.py`) require only `numpy`, `cmath`, and `copy`

* The modules containing the test suites (`oscprob2nu_tests.py`, `oscprob3nu_tests.py`, `oscprob3nu_plotpaper.py`, and `oscprob_testsuite.py`) require only `numpy`, `cmath`, `copy`, and `matplotlib`


## Installation

Because **NuOscProbExact** is written fully in Python, no compilation or linking is necessary.  The installation amounts to fetching the files from GitHub and is simple.

> **Python 2 compatibility:** The code was written and tested using Python 3.  Yet, because the core modules `oscprob2nu.py` and `oscprob3nu.py` use only native Python functions and popular modules, they might also run in Python 2.  However, this is currently untested.

Instructions:

1. In the file system where you would like to install **NuOscProbExact**, go to the directory where you would like the code to be downloaded, *e.g.*,
   ```shell
   cd /home/MyProjects
   ```

2. From there, fetch the code from the GitHub repository with
   ```shell
   git clone https://github.com/mbustama/NuOscProbExact.git
   ```
   (Alternatively, you can download the zip file from GitHub and uncompress it.)

   Doing this will create the directory `/home/MyProjects/NuOscProbExact`, with the following file structure:
   ```
   /NuOscProbExact/run_testsuite.py    Run this to create test plots of the probabilities
   /NuOscProbExact/fig                 Contains plots generate by the test suite (initially empyty)
   /NuOscProbExact/src                 Contains the main source files
       ../hamiltonians2nu.py           Routines to compute example two-flavor Hamiltonians
       ../hamiltonians3nu.py           Routines to compute example three-flavor Hamiltonians
       ../globaldefs.py                Physical constants
       ../oscprob2nu.py                Routines to compute the two-flavor probabilities
       ../oscprob3nu.py                Routines to compute the three-flavor probabilities
   /NuOscProbExact/test                Contains the source files to run the test suite
       ../matplotlibrc                 Customized matplotlib style file
       ../oscprob3nu_plotpaper.py      Routine to generate the plot shown in the paper
       ../oscprob3nu_tests.py          Routines to generate three-flavor probability tests plots
   ```
   Now you are ready to start using **NuOscProbExact**.

3. (Optional) Run the test suite
   ```shell
   cd /home/MyProjects/NuOscProbExact
   python run_testsuite.py
   ```
   Doing this will create plots of the probabilities *vs.* distance and *vs.* energy, for different oscillation scenarios.  The plots will be stored in the `NuOscProbExact/fig` directory.  The plots are generated by the source files located in the `NuOscProbExact/test/` directory.  Inspecting these files may help you in coding your own project.


## Usage

There are only two core modules: `oscprobn2nu.py` and `oscprob3nu.py`.  Each one is stand-alone (except for the dependencies described [above](#requirements)).  To use either in your code, copy it to your project's working directory (or add their location to the paths where your environment looks for modules).

In the examples below, we focus on `oscprob3nu.py`, but what we show applies to `oscprob2nu.py` as well.

### Basics

The only input parameters given to `oscprob3nu.py` is the Hamiltonian, in the form of a 3x3 Hermitian matrix, and the baseline.  (For `oscprob2nu.py`, it is a 2x2 Hermitian matrix.)  The Hamiltonian is passed to the routines as a list, *i.e.*,
```python
hamiltonian = [[H11, H12, H13], [H21, H22, H23], [H31, H32, H33]]
```
Beware: if you feed the code a non-Hermitian matrix, it will output nonsensical results.

Most of the time, you will be only interested in computing oscillation probabilities.  The function to compute probabilities is `probabilities_3nu`.  It takes in `hamiltonian` and `L` as input parameters and returns the list of probabilities Pee, Pem, Pet, Pme, Pmm, Pmt, Pte, Ptm, Ptt.

### Trivial example

Let's feed it an arbitrary Hamiltonian and baseline:
```python
import oscprob3nu
import cmath

hamiltonian = [
                [1.0+0.0j, 0.0+2.0j, 0.0-1.0j],
                [0.0-2.0j, 3.0+0.0j, 3.0+0.0j],
                [0.0+1.0j, 3.0-0.0j, 5.0+0.0j]
]

L = 1.0

Pee, Pem, Pet, Pme, Pmm, Pmt, Pte, Ptm, Ptt = oscprob3nu.probabilities_3nu(hamiltonian, L)

print("Pee = %6.5f, Pem = %6.5f, Pet = %6.5f" % (Pee, Pem, Pet))
print("Pme = %6.5f, Pmm = %6.5f, Pmt = %6.5f" % (Pme, Pmm, Pmt))
print("Pte = %6.5f, Ptm = %6.5f, Ptt = %6.5f" % (Pte, Ptm, Ptt))
```
This returns
```shell
Pee = 0.34273, Pem = 0.41369, Pet = 0.24358
Pme = 0.41369, Pmm = 0.00485, Pmt = 0.58146
Pte = 0.24358, Ptm = 0.58146, Ptt = 0.17497
```

As expected, `Pem == Pme`, `Pet == Pte`, `Pmt == Ptm`, `Pee + Pem + Pet = 1`, , `Pme + Pmm + Pmt = 1`, and `Pte + Ptm + Ptt = 1`.


### Oscillations in vacuum: fixed energy and baseline

Now let's compute the probabilities in vacuum.  To do this, we can use the routine
```python
hamiltonian_vacuum_energy_independent(s12, s23, s13, dCP, D21, D31)
```
that is provided in the `hamiltonians3nu.py` module.  The input parameters `s12`, `s23`, `s13`, `dCP`, `D21`, and `D31` are, respectively, sin(theta_12), sin(theta_23), sin(theta_13), delta_CP, Delta m_21^2, and Delta m_31^2.  For this example, we set them to their current best-fit values, which we pull from `globaldefs.py` (see that file for more information about these values).

> **Important:** The function `hamiltonian_vacuum_energy_independent` returns the Hamiltonian in vacuum **without** the *1/E* prefactor, where *E* is the neutrino energy.  It was done in this way so that, if we wish to compute the probabilities at different energies, we need compute `hamiltonian_vacuum_energy_independent` only once, and then multiply it by a varying *1/E* prefactor.

```python
import oscprob3nu
import hamiltonians3nu
from globaldefs import *

energy = 1.e9     # Neutrino energy [eV]
baseline = 1.3e3  # Baseline [km]

h_vacuum_energy_indep = hamiltonians3nu.hamiltonian_vacuum_energy_independent(  S12_BF, S23_BF,
                                                                                S13_BF, DCP_BF,
                                                                                D21_BF, D31_BF)
h_vacuum = np.multiply(1./energy, h_vacuum_energy_indep)

Pee, Pem, Pet, Pme, Pmm, Pmt, Pte, Ptm, Ptt = oscprob3nu.probabilities_3nu( \
                                                h_vacuum, baseline*CONV_KM_TO_INV_EV)

print("Pee = %6.5f, Pem = %6.5f, Pet = %6.5f" % (Pee, Pem, Pet))
print("Pme = %6.5f, Pmm = %6.5f, Pmt = %6.5f" % (Pme, Pmm, Pmt))
print("Pte = %6.5f, Ptm = %6.5f, Ptt = %6.5f" % (Pte, Ptm, Ptt))
````
This returns
```shell
Pee = 0.96711, Pem = 0.01593, Pet = 0.01695
Pme = 0.01823, Pmm = 0.64417, Pmt = 0.33761
Pte = 0.01466, Ptm = 0.33990, Ptt = 0.64544
```

### Oscillations in vacuum: fixed energy, varying baseline

Now we fix the energy at, say 10 MeV, and vary the baseline between 1 and 500 km.  We use a fine grid in `L` so that the oscillations are clearly rendered.

```python
import oscprob3nu
import hamiltonians3nu
from globaldefs import *

energy = 1.e7     # Neutrino energy [eV]

# Baselines, L
log10_l_min = 0.0          # log10 [km]
log10_l_max = log10(5.e2)  # log10 [km]
log10_l_npts = 6000
log10_l_val = np.linspace(log10_l_min, log10_l_max, log10_l_npts)  # [km]
l_val = [CONV_KM_TO_INV_EV*10.**x for x in log10_l_val]


h_vacuum_energy_indep = hamiltonians3nu.hamiltonian_vacuum_energy_independent(  S12_BF, S23_BF,
                                                                                S13_BF, DCP_BF,
                                                                                D21_BF, D31_BF)
h_vacuum = np.multiply(1./energy, h_vacuum_energy_indep)

# Each element of prob: [Pee, Pem, Pet, Pme, Pmm, Pmt, Pte, Ptm, Ptt]
prob = [oscprob3nu.probabilities_3nu(h_vacuum, l) for l in l_val]
prob_ee = [x[0] for x in lst_prob]  # Pee
prob_em = [x[1] for x in lst_prob]  # Pem
prob_et = [x[2] for x in lst_prob]  # Pet
```

To visualize the data:


Alternatively, you can automatically produce plots of probability using following function from the `oscprob3nu_tests` module:
```python
case = 'vacuum'
plot_probability_3nu_vs_l(  case, energy_nu=1.e7,
                            output_filename='prob_3nu_vacuum_vs_l', output_format='pdf',
                            log10_l_min=0.0, log10_l_max=log10(5.e2), log10_l_npts=6000,
                            plot_prob_ee=True, plot_prob_em=True, plot_prob_et=True)
```
The parameter `case` be:
* `vacuum`: for oscillations in vacuum, assuming the default values of mixing parameters from the `globaldefs` module
* `matter`: for oscillations in constant matter, assuming the density of the Earth's crust as set in `globaldefs`
* `nsi`: for oscillations in matter with non-standard interactions, with the NSI strengh parameters fixed to the default values in `globaldefs`
* `liv`: for oscillations in a CPT-odd Lorentz invariance-violating (LIV) background, with the LIV parameters fixed to the default values in `globaldefs`
For more information about these cases, refer to the paper [arXiv:1904.XXXXX](https://arxiv.org/abs/1904.XXXXX) and inspect the contents of the file `globaldefs.py`.


### Oscillations in vacuum: fixed baseline, varying energy


## Documentation and help

All of the modules provided in **NuOscProbExact** have been documented using Python docstrings.  These are human-readable by opening the source `.py` files.  Alternatively, they can be printed from within an interactive Python session.

To view the documentation of a module from within an interactive Python session, run, *e.g.*,
```python
import oscprob3nu

print(oscprob3nu.__doc__)
```
This will print to screen a description of what the module does (in this example, `oscprob3nu`) and a list of the functions that it contains, including a description of each.

To view the documentation of a particular function from within an interactive Python session, run, *e.g.*,
```python
import oscprob3nu

help(oscprob3nu.hamiltonian_3nu_coefficients)
```
This will print to screen a description of what the function does (in this example, `oscprob3nu.hamiltonian_3nu_coefficients`), a list and description of its input parameters, and a description of the values that it returns.


## Citing

If you use **NuOscProbExact** in your work, we ask you that you please cite the following paper: Mauricio Bustamante, *Exact neutrino oscillation probabilities with arbitrary time-independent Hamiltonians*, [arXiv:1904.XXXXX](https://arxiv.org/abs/1904.XXXXX).

If you are citing **NuOscProbExact** in a document that will be uploaded to the arXiv, please consider using the LaTeX or BibTeX entries provided by INSPIRE.





